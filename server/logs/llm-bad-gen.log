[2025-08-11T14:03:43.058Z] schema-validation-failed {"topic":"Data Structures and Algorithms","difficulty":3,"count":5,"cleaned":"{\"topic\":\"Data Structures and Algorithms\",\"total\":5,\"difficulties\":[3],\"questions\":[{\"difficulty\":3,\"cognitiveLevel\":\"analyze\",\"stem\":\"Which of the following is NOT a property that must hold for a red‑black tree after any insertion or deletion operation?\",\"choices\":[\"Every node is either red or black.\",\"The root is always black.\",\"All leaves (NIL nodes) are black.\",\"The number of black nodes on any path from the root to a leaf can differ by at most one.\"],\"answerIndex\":3,\"explanation\":\"In a red‑black tree, the number of black nodes on all paths from the root to a leaf must be the same; they cannot differ by one. The other three statements are standard properties of red‑black trees.\",\"tags\":[\"tree\",\"balanced\",\"red-black\"]},{\"difficulty\":3,\"cognitiveLevel\":\"analyze\",\"stem\":\"What is the time complexity of Dijkstra's algorithm when implemented with a binary heap and adjacency list representation for a graph with V vertices and E edges?\",\"choices\":[\"O(V^2)\",\"O(E log V)\",\"O(V log V + E)\",\"O((V+E) log V)\"],\"answerIndex\":3,\"explanation\":\"With a binary heap, each decrease‑key operation costs O(log V). The algorithm performs O(E) such operations and extracts the minimum O(V) times, yielding O((V+E) log V).\",\"tags\":[\"graph\",\"shortest-path\",\"dijkstra\"]},{\"difficulty\":3,\"cognitiveLevel\":\"analyze\",\"stem\":\"Which of the following statements about the Longest Increasing Subsequence (LIS) problem is true?\",\"choices\":[\"It can be solved in O(n log n) time using patience sorting.\",\"It has a polynomial-time dynamic programming solution with O(n^2) time.\",\"The LIS of a permutation of length n is always of length ⌈n/2⌉.\",\"Both A and B are correct.\"],\"answerIndex\":3,\"explanation\":\"The LIS problem admits both an O(n^2) DP solution and an O(n log n) patience‑sorting solution; the statement about length ⌈n/2⌉ is false.\",\"tags\":[\"dynamic-programming\",\"sequence\",\"lcs\"]},{\"difficulty\":3,\"cognitiveLevel\":\"analyze\",\"stem\":\"In a hash table that uses open addressing with quadratic probing, which of the following is a potential drawback compared to separate chaining?\",\"choices\":[\"Higher memory overhead.\",\"Possibility of clustering.\",\"Requires rehashing less often.\",\"Insertion time can become O(1) in the worst case.\"],\"answerIndex\":1,\"explanation\":\"Quadratic probing can suffer from primary clustering, whereas separate chaining does not exhibit this issue. The other choices are not drawbacks of quadratic probing.\",\"tags\":[\"hashing\",\"open-addressing\",\"quadratic-probing\"]},{\"difficulty\":3,\"cognitiveLevel\":\"analyze\",\"stem\":\"Which of the following statements about breadth‑first search (BFS) in an unweighted graph is false?\",\"choices\":[\"BFS can be used to find the shortest path in terms of number of edges.\",\"BFS explores vertices in order of increasing distance from the source.\",\"BFS guarantees to visit all vertices reachable from the source.\",\"BFS can be implemented using a stack instead of a queue without affecting its correctness.\"],\"answerIndex\":3,\"explanation\":\"BFS must use a queue to maintain the order of exploration; using a stack would turn it into DFS and change its behavior.\",\"tags\":[\"graph\",\"bfs\",\"shortest-path\"]}]}","zod":{"formErrors":[],"fieldErrors":{"difficulty":["Required"]}}}
[2025-08-11T14:23:34.459Z] json-parse-error {"topic":"Data Structures and Algorithms","difficulty":3,"count":5,"cleaned":"{\"topic\":\"Data Structures and Algorithms\",\"difficulty\":3,\"questions\":[{\"stem\":\"What is the time complexity of binary search on a sorted array of size n?\",\"choices\":[\"O(n)\",\"O(log n)\",\"O(n log n)\",\"O(1)\"],\"answerIndex\":1,\"explanation\":\"Binary search halves the search space each iteration, yielding log₂n steps.\",\"tags\":[\"complexity\",\"search\",\"binary search\"]},{\"stem\":\"Which data structure pair is most efficient for implementing an LRU cache?\",\"choices\":[\"Queue + HashMap\",\"Stack + HashMap\",\"Doubly linked list + HashMap\",\"Binary tree + HashMap\"],\"answerIndex\":2,\"explanation\":\"A doubly linked list allows O(1) removal/insertion of most-recently used items, while a hashmap gives O(1) access.\",\"tags\":[\"data-structures\",\"LRU\",\"cache\"]},{\"stem\":\"Which graph traversal algorithm guarantees the shortest path in an unweighted graph?\",\"choices\":[\"Depth‑First Search\",\"Breadth‑First Search\",\"Dijkstra's algorithm\",\"Prim's algorithm\"],\"answerIndex\":1,\"explanation\":\"BFS explores nodes level by level, ensuring the fewest edges to each vertex.\",\"tags\":[\"graphs\",\"traversal\",\"BFS\"]},{\"stem\":\"In Hoare's partition scheme, what is the role of the pivot element?\",\"choices\":[\"The element to be removed\",\"The element that will be placed at its final position after partition\",\"The element used to split array into parts but not necessarily final position\",\"The element used only for comparison but not moved\"],\"answerIndex\":2,\"explanation's scheme partitions without guaranteeing the pivot's final position; it merely divides the array.\",\"tags\":[\"sorting\",\"quicksort\",\"partition\"]},{\"stem\":\"Which statement best describes the principle of optimality in dynamic programming?\",\"choices\":[\"Optimal solution can be built by solving subproblems optimally\",\"Subproblems are independent\",\"The problem can be solved in linear time\",\"Only greedy solutions are optimal\"],\"answerIndex\":0,\"explanation\":\"The principle states that an optimal solution contains optimal solutions to its subproblems.\",\"tags\":[\"dynamic-programming\",\"optimality\",\"principle\"]}]}","error":"SyntaxError: Unexpected token ',', ...\"he array.\",\"tags\":[\"\"... is not valid JSON"}
